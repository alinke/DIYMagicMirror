<?xml version="1.0" encoding="utf-8"?>
<!--
/**
 * MonkeyTab
 * 
 * A small UI Component that compare some openSSL 
 * outputs to the output generated by 
 * the algorithms of the AS3 Crypto library.
 * Copyright (c) 2007 Henri Torgemane
 * 
 * See LICENSE.txt for full license information.
 */
-->
<mx:VBox xmlns:mx="http://www.adobe.com/2006/mxml" 
	label="OpenSSL Monkey" width="100%" height="100%"
	creationComplete="init()">
	<mx:Text width="100%">
		<mx:htmlText>
		<![CDATA[When you press start, this tab will generate random keys, IVs and plain texts for a number of encryption modes.
The encryption and decryption will be performed by an <a href="http://crypto.hurlant.com/openssl.php?view=1">openSSL 0.9.7a script on hurlant.com</a>, as well as by this library.
Any discrepancy will be flagged.
The whole thing is pretty slow. You've been warned.
]]>
		</mx:htmlText>
	</mx:Text>
	<mx:HBox width="100%">
		<mx:Button id="btn" label="Start" click="start()"/>
		<mx:Label id="summary" width="100%"/>
	</mx:HBox>
	<mx:TextArea id="console" width="100%" height="100%" editable="false" fontFamily="Courier New"/>
	<mx:Script>
		<![CDATA[
			import com.hurlant.util.Hex;
			import com.hurlant.crypto.symmetric.IVMode;
			import com.hurlant.crypto.symmetric.ICipher;
			import com.hurlant.crypto.prng.Random;
			import com.hurlant.crypto.Crypto;
			// list of cipher types currently shared with the openSSL command line
			private var cipherList:Array = [
				"aes-128-cbc",
				"aes-128-cfb",
//				"aes-128-cfb8",
				"aes-128-ecb",
				"aes-128-ofb",
				"aes-192-cbc",
				"aes-192-cfb",
//				"aes-192-cfb8",
				"aes-192-ecb",
				"aes-192-ofb",
				"aes-256-cbc",
				"aes-256-cfb",
//				"aes-256-cfb8",
				"aes-256-ecb",
				"aes-256-ofb",
				"aes128",
				"aes192",
				"aes256",
				"bf",
				"bf-cbc",
				"bf-cfb",
				"bf-ecb",
				"bf-ofb",
				"blowfish",
				"des",
				"des-cbc",
				"des-cfb",
//				"des-cfb8",
				"des-ecb",
				"des-ede",
				"des-ede-cbc",
				"des-ede-cfb",
				"des-ede-ofb",
				"des-ede3",
				"des-ede3-cbc",
				"des-ede3-cfb",
				"des-ede3-ofb",
				"des-ofb",
//				"des3", // duplicate of des-ede3-cbc
				"rc4",
				"rc4-40",
			];
			private const TRIES:uint = 3;
			private var cipherIndex:int = -1;
			private var tryCount:uint = 0;
			private var testFailed:int = 0;
			private var testCount:int = 0;
			private var testTotal:int = cipherList.length * TRIES * 2;
			private var cipher:ICipher; // current cipher
			private var key:ByteArray;  // current key
			private var iv:ByteArray;   // current iv;
			private var src:ByteArray;  // copy of the source text
			private var text:ByteArray; // current chunk, encrypted or not.
			
			private var rand:Random; // we need a lot of random bytes.
			
			
		
			private function clear():void {
				console.htmlText = "";
			}
			private function write(str:String):void {
				console.htmlText+=str;
			}
			private function writeln(str:String):void {
				console.htmlText+=str+"\n";
			}
			private function summarize():void {
				summary.htmlText = '<B><FONT COLOR="'+(testFailed>0?"#7F0000":"#007F00")+'">'+(testCount-testFailed)+"/"+testTotal+" tests passed."+(testFailed>0?" "+testFailed+" FAILURES!":"")+"</FONT></B>";
			}

			private function init():void {
				rand = new Random;
			}
			private function start():void {
				clear();
				cipherIndex=-1;
				tryCount=0;
				testFailed=0;
				testCount=0;
				nextCipher();
			}
			
			private function nextCipher():void {
				cipherIndex++;
				tryCount = 0;
				if (cipherIndex == cipherList.length) {
					// done.
					writeln("Done.");
					return;
				}
				var keyLength:uint = Crypto.getKeySize(cipherList[cipherIndex]);
				key = new ByteArray;
				rand.nextBytes(key, keyLength);
				callLater(nextTry);
			}
			private function nextTry():void {
				if (tryCount>=TRIES) {
					writeln("Ran "+tryCount+" tries with "+cipherList[cipherIndex]);
					nextCipher();
					return;
				}
				cipher = Crypto.getCipher(cipherList[cipherIndex], key);
				tryCount++;
				iv = new ByteArray;
				rand.nextBytes(iv, cipher.getBlockSize());
				if (cipher is IVMode) {
					var ivm:IVMode = cipher as IVMode;
					ivm.IV = iv;
				}
				text = new ByteArray;
				var len:uint = rand.nextByte()+1; // between 1 and 256
				rand.nextBytes(text, len);
				src = new ByteArray;
				src.writeBytes(text);
				askOpenSSL({
					cipher: cipherList[cipherIndex],
					key: Hex.fromArray(key),
					iv: Hex.fromArray(iv),
					mode: "e",
					src: Hex.fromArray(text)},
					encResult);
				// compute our own result.
				cipher.encrypt(text);
			}
			private function encResult(e:Event):void {
				var dst:String = URLLoader(e.target).data as String;
				// compare dst and data
				var as3:String = Hex.fromArray(text);
				if (as3!=dst) {
					writeln('<font color="#7F0000">FAIL! - '+cipherList[cipherIndex]+" aka "+cipher.toString()+"</font>");
					writeln("  KEY="+Hex.fromArray(key));
					writeln("  IV="+Hex.fromArray(iv));
					writeln("  MODE=encrypt");
					writeln("  SRC="+Hex.fromArray(src));
					writeln(" OpenSSL OUTPUT="+dst);
					writeln(" Library OUTPUT="+as3);
					testFailed++;
				}
				testCount++;
				summarize();
				// ok. decrypt.
				cipher = Crypto.getCipher(cipherList[cipherIndex], key);
				if (cipher is IVMode) {
					var ivm:IVMode = cipher as IVMode;
					ivm.IV = iv;
				}
				src.position=0;
				src.writeBytes(text);
				askOpenSSL({
					cipher: cipherList[cipherIndex],
					key: Hex.fromArray(key),
					iv: Hex.fromArray(iv),
					mode: "d",
					src: Hex.fromArray(text)},
					decResult);
				cipher.decrypt(text);
			}
			private function decResult(e:Event):void {
				var dst:String = URLLoader(e.target).data as String;
				// compare dst and data
				var as3:String = Hex.fromArray(text);
				if (as3!=dst) {
					writeln('<font color="#7F0000">FAIL! - '+cipherList[cipherIndex]+" aka "+cipher.toString()+"</font>");
					writeln("  KEY="+Hex.fromArray(key));
					writeln("  IV="+Hex.fromArray(iv));
					writeln("  MODE=decrypt");
					writeln("  SRC="+Hex.fromArray(src));
					writeln(" OpenSSL OUTPUT="+dst);
					writeln(" Library OUTPUT="+as3);
					testFailed++;
				}
				testCount++;
				summarize();
				
				callLater(nextTry);
			}
			////////
			// Network request to compute something
			private function askOpenSSL(data:Object, cb:Function):void {
				var loader:URLLoader = new URLLoader;
				var req:URLRequest = new URLRequest("http://crypto.hurlant.com/openssl.php");
				var vars:URLVariables = new URLVariables;
				for (var key:String in data) {
					vars[key] = data[key];
				}
				req.method = URLRequestMethod.GET;
				req.data = vars;
				loader.addEventListener(Event.COMPLETE, cb);
				loader.addEventListener(Event.COMPLETE, closeLoader);
				loader.load(req);
			}
			private function closeLoader(e:Event):void {
				var loader:URLLoader = URLLoader(e.target);
				loader.close();
			}
			
		]]>
	</mx:Script>	
</mx:VBox>